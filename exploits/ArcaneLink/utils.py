from typing import List
import requests, base64
from pwn import *

SERVICE_PORT = 1337
TOKEN_SERVER_IP = '10.10.0.5'

def get_token_server() -> str:
    if args.TOKENSERVER:
        return args.TOKENSERVER
    return TOKEN_SERVER_IP

def get_new_token(target: str) -> str:
    try:
        resp = requests.get(f'http://{get_token_server()}/token', params={
            'target':  '10.64.255.1' if args.DEV else target
        }, timeout=30)
        raw_data = resp.content
        data = resp.json()
    except (requests.ConnectionError, requests.ConnectTimeout):
        log.error('Token server is unreachable')
    except requests.JSONDecodeError:
        log.error('Token server returned an invalid response: %s', repr(raw_data))

    if resp.status_code != 200:
        log.error(f'Token server returned HTTP %d: %s', resp.status_code, data)

    return data

def start_vm(target_ip: str, token: str, arch: str) -> pwnlib.tubes.sock:
    if arch not in ['i386', 'arm64']:
        log.error('Arch %s is invalid', arch)

    r = remote(target_ip, SERVICE_PORT)

    prompt = r.recvuntil(b'Token: ', timeout=15)
    if not prompt.startswith(b'Token: '):
        log.error('Error or timeout connecting (backend down?): %s', prompt)

    r.sendline(token.encode())

    prompt = r.recvline(keepends=False)
    if not prompt.startswith(b'Session expires in'):
        log.error('Token refused: %s', prompt)

    r.sendlineafter(b'Select VM: ', f'ic3-bookworm-{arch}'.encode())
    r.recvuntil(b'-' * 70 + b'\n')
    return r

def command(r: pwnlib.tubes.sock, cmd: str):
    r.recvuntil(b'$ ')
    r.sendline(cmd.encode())

def command_output(r: pwnlib.tubes.sock, cmd: str) -> bytes:
    command(r, cmd)

    output = r.recvuntil(b'$ ')
    r.unrecv(b'$ ')
    return output


def upload_exploit_b64(r: pwnlib.tubes.sock, text: str, remote_path: str):
    command(r, f'rm -f {remote_path}')

    p = log.progress('Uploading base64 encoded exploit')
    chunksz = 0x1000
    for i in range(0, len(text), chunksz):
        p.status(f'{i}/{len(text)} bytes')
        log.info
        command(r, f'echo "{text[i:i+chunksz]}" >> {remote_path}')
    p.success('Done')

def upload_exploit(r: pwnlib.tubes.sock, exploit_bin_path: str, remote_bin_path: str):
    with open(exploit_bin_path, 'rb') as f:
        exploit_data = f.read()

    exploit_b64 = base64.b64encode(exploit_data).decode()
    tmp_remote_path = f'/tmp/{os.urandom(32).hex()}'
    upload_exploit_b64(r, exploit_b64, tmp_remote_path)
    command(r, f'base64 -d {tmp_remote_path} > {remote_bin_path}')
    command(r, f'rm -f {tmp_remote_path}')
    command(r, f'chmod +x {remote_bin_path}')

def compile_exploit(expl_source_path: str, expl_bin_dest: str, flags: List[str]):
    if os.path.isfile(expl_bin_dest):
        # Already compiled
        return

    p = process(['aarch64-linux-gnu-gcc', expl_source_path, '-o', expl_bin_dest] + flags, shell=False)
    if p.poll(block=True) != 0:
        log.error('Error while compiling exploit: %s', p.recvall())
    p.close()

    p = process(['aarch64-linux-gnu-strip', expl_bin_dest], shell=False)
    if p.poll(block=True) != 0:
        log.error('Error while stripping exploit: %s', p.recvall())
    p.close()

    log.info("Exploit built")
